# Fill in your name, student ID, and email address in this file.
# If you are working in a team, fill out the information for both team 
# members.

# SUBMIT THE LAB ONLY ONCE (from only one partner). This file will be
# automatically parsed in order to give both team members credit for the
# lab.

# You need to fill in the EXERCISE sections describing your solutions
# for Tasks 1, 2, and 3, as well as write the corresponding code.
# If you did one or more extra credit problems, indicate which one in the
# appropriate section below (remove the # sign first). If you have any other
# information you'd like us to know, please add it at the end of the file.

# Partner 1
Name: Baixiao Huang
Student ID: 504313981
Email: huangbaixiao@g.ucla.edu

# Partner 2 (if you're working in a team)
Name: Jiayi Lu
Student ID: 004079546
Email: luckyjinglebell@gmail.com

# EXERCISE 1: What method you used to make your peer download and upload
#    files in parallel?  (~1-3 sentences)
I used fork() in the main function. Every time parent program try to download
a file from a pear, it forks a child process to do the job (parent is too lazy
to do the job).

# EXERCISE 2A: What conditions did you find and fix that would have
#    triggered a buffer overrun bug?  (~1-3 sentences each)
If a peer sends a big file name, when program is trying to read that file name
from buffer to filename buffer in format “GET %s OSP2P”, it will write out of
filename buffer and write to disk_filename buffer as well as peer_list pointer.
Then a list of peer will be lost, your program cannot request another peer
for the file.

# EXERCISE 2B: What other robustness problems did you fix?  (~1-3 sentences
#    each)
1)
When you send upload file /dev/random to another peer, file will be very big and eat up
downloading peer’s disk.
So I limit the maximum number of bytes can be transferred to 100 MB in task_upload function.
So a very big file transfer like /dev/random can be prevented. This programs is tested
by setting up another peer.

2)
A malicious peer can attack another seeder peer by lying to tracker, say, telling 
tracker to get cat3.jpg, when actually it is not requesting cat3.jpg. Then tracker 
will give malicious peer a list of IP address, so mit can ask for file
other than cat3.jpg from these IP address.For example, it can ask for ‘/etc/passwd’.
And seeder peer will, without realizing the danger, send the file to attacker.
To solve it, peer needs to check if requesting filename contains ’/’, so that files
other than working directory won’t be fetched. A checking function is implemented
in task_upload(). Program robustness against this attack was tested.

3)
Data from a popular tracker could contains too many IP

# EXERCISE 3: Describe the attacks you implemented for "evil mode".  Why
#    are they attacks?  (~3-10 sentences each)

# Extra credit problems
#Extra credit problem: none

# Add any other information you'd like us to know below this line.
